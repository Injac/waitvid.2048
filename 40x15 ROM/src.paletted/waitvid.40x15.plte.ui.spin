'''' VGA display 40x15 (single cog, ROM font, palette) - user interface''''        Author: Marko Lukat'' Last modified: 2013/10/27''       Version: 0.1.pal.3'''' 20131025: allow for startup vgrp/vpin configuration'' 20131027: moved video setup to top level''CON  columns  = driver#res_x / 16  rows     = driver#res_y / 32  bcnt     = columns * rows  rows_raw = (driver#res_y + 32 - 1) / 32  bcnt_raw = columns * rows_rawCON  #8, BS, TAB, LF, VT, FF, CR, ESC = 27OBJ  driver: "waitvid.40x15.plte.driver"    VAR  long  link[driver#res_m]                              ' driver mailbox  word  scrn[bcnt_raw / 2]                              ' screen buffer (2n aligned)  word  indx[bcnt_raw / 2]                              ' colour buffer (2n aligned)  byte  x, y, page, colour                              ' cursor position, page mode, colour  word  flag  PUB null'' This is not a top level object.PUB init(vgrp_vpin)  out(FF)                                               ' clear screen    link{0} := @scrn{0}                                   ' initial screen and  link[2] := @indx{0}                                   ' colour index buffer (default palette)  link[3] := vgrp_vpin                                  ' vgrp/vpin  return driver.init(-1, @link{0})                      ' video driver and pixel generator  PUB setn(n, addr)  link[n] := addr  repeat  while link[n]PUB putc(c)  indx.byte[y * columns + x] := colour                  ' update colour  scrn.byte[y * columns + x] := c                       ' update character  if ++x == columns                                           x := newline                                        ' CR/LFPRI newline  if ++y == rows    if page                                             ' page/scroll?      y := 0      return    y--    wordmove(@indx{0}, @indx.byte[columns], constant((bcnt_raw - columns) / 2))    wordmove(@scrn{0}, @scrn.byte[columns], constant((bcnt_raw - columns) / 2))    if rows_raw == rows      wordfill(@indx.byte[constant(bcnt_raw - columns)], colour * $0101, constant(columns / 2))      wordfill(@scrn.byte[constant(bcnt_raw - columns)], $2020, constant(columns / 2))PUB str(addr)  repeat strsize(addr)    out(byte[addr++])PUB out(c) : succ'' Output a character''''     $00 = NUL   clear screen''     $01 = SOH   home''     $08 = BS  * backspace''     $09 = TAB * tab''     $0A = LF    set X position (X follows)''     $0B = VT    set Y position (Y follows)''     $0C = FF  * clear screen''     $0D = CR  * return''     $1B = ESC sequence(s)''  others = printable characters  case flag.byte{0}    $00: case c                                                        $00..$01,FF:                                         if c <> $01                                          wordfill(@indx{0}, colour * $0101, constant(bcnt_raw / 2))               wordfill(@scrn{0}, $2020, constant(bcnt_raw / 2))             x := y := 0                                      $08: x := (x - 1) #> 0                             TAB: repeat 8 - (x & 7)                                      putc(" ")                                    $0A..$0B: flag := c << 8 | "="               ' emulate head/tail of ESC=<x><y>           $0D: x := newline                            ' CR/LF           ESC: flag := c                                      other: putc(c)                                ESC: case c           "s", "S": page := c & $20                    ' page (ESC+s) and scroll mode (ESC+S)           "=":      succ := constant($0200 | "=")      ' ESC=<x><y>           "c":      succ := constant($0100 | "c")      ' ESCc<indx>         flag := succ~    "=": case flag.byte[1]--           2..10: flag &= tr(c, @x, columns, flag >> 11)           other: flag := tr(c, @y, rows, TRUE)    "c": colour := c            flag := 0         PRI tr(c, addr, limit, response)  if c.byte{0} < 255    byte[addr] := c.byte{0} // limit  return not responseDAT