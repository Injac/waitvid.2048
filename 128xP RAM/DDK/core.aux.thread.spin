'''' cog binary loader - user interface (counter mode)''''        Author: Marko Lukat'' Last modified: 2012/04/15''       Version: 0.16.ctr.9'''' acknowledgements'' - overlay loader based on work done by Phil Pilgrim (PhiPi) and Ray Rodrick (Cluso99)'''' 20100116: removed shutdown code'' 20100123: added launch method'' 20100129: split encodeLoad into SE/SL variants'' 20101205: set carry on entry to any overlay fn'' 20101208: create() failure triggers abort'' 20110204: launch() failure triggers abort'' 20111019: lowered latency for loader part''           - command read at hub(N+0)''           - 1st transfer at hub(N+2)'' 20111022: added functionality for dynamic name mapping (version transition support)'' 20111210: command location can now be retargeted, default is par'' 20120408: launch() now takes an ID as well (ignored for overlays)'' 20120414: extended resolve(), may return long values as well''CON  cmdDONE = $001  ' done        clear current, fetch next command  cmdIDLE = $002  ' idle                       fetch next command  cmdLOAD = $006  ' load  cmdHEAP = $010  ' heap  cmdMASK = $1FF  regADDR = addr  ' command value (payload:cmd = 23:9)  regLINK = link  ' command location (r/w)  dstZERO = zero  ' destination slot onlyOBJ  system: "core.con.system"  PUB null              '' This is not a top level object.PUB create(ID, command, wait, mark)'' Creates a new overlay thread either with a specific or the next available ID.'''' parameters''       ID: thread/cog ID''           0..7: coginit, otherwise cognew (may fail)''  command: hub location for command (long address)''     wait: wait for thread to start execution (boolean)''     mark: mark command slot for external synchronisation (boolean)'''' result''     == 0: [ABORT] thread creation failed (cognew only)''     <> 0: thread/cog ID + 1  if wait or mark    long[command] := cmdIDLE  result := system.launch(ID, @thread, command)  repeat while wait and long[command]PUB launch(ID, address, command, overlay) | cbase'' Launches an overlay or a cog binary.'''' parameters''       ID: cog ID (ignored for overlays)''           0..7: coginit, otherwise cognew (may fail)''  address: ... of buffer holding the code''  command: par[ameter] for cog binaries''  overlay: overlay command listener'''' result''     == 0: [ABORT] launch failed''     <> 0: cog ID + 1 or TRUE (overlay)'''' Note: If either command or overlay are not 4n aligned then loading of their''       respective type of binary is blocked, e.g. launch(-1, buffer, %11, addr_4n)''       will only accept overlays.  if long[address] == system#ID_2                       ' magic number for cog binary    if (cbase := word[address][2]) > 2                  ' validate header length      cbase := @long[address][cbase]                    ' payload address      ifnot word[address][3] & system#OVERLAY           ' raw cog code, use cognew/coginit        if command & %11                                ' last chance to block this          abort                                         ' - binaries blocked        return system.launch(ID, cbase, command)      if word[address][4] == cmdHEAP                    ' can we handle this?        ifnot overlay & %11 or long[overlay]            ' blocked and/or busy          long[overlay] := encodeLoadSL(cbase, word[address][5] << 2)          return TRUE                                                        ' - wrong signature or invalid header length                                                        ' - invalid overlay (entry point not recognised)  abort                                                 ' - overlays blocked or overlay thread busyPUB resolve(base, name, default) | limit, n, names'' Translates a given symbol name into its mapped value.'''' parameters''     base: address of cog binary image (header)''     name: address of symbol name (zero terminated string)''  default: response if name can't be resolved or mapping isn't supported'''' result''  mapped value or default response (not found/supported)  if word[base][3] & system#MAPPING                     ' only if supported    base  +=  word[base][6]                             ' translation table address    limit :=  word[base]{0}                             ' string array word offset    names := @word[base][limit--]                       ' string array address    repeat n from 1 to limit                            ' loop over all entries      if strcomp(name, names)                           ' match names        if (result := word[base][n]) > $7FFF            ' (relative) long index?          result := long[base][(result << 17) ~> 17]    ' final translation        return                                          ' return corresponding entry      names += strsize(names) + 1{terminator}           ' advance to next string                                                        ' - mapping not supported  return default                                        ' - name not found  PUB encodeLoadSE(start, end) | cog, hub, ofs'' Encodes a pair of hub addresses into a load command.'''' parameters''    start: address of code fragment       ''      end: address of last long in code fragment'''' result''  command: load command  ofs := (((end - start + 11) & -8) - 4) >> 2           ' (8n-4)/4  hub := ofs + start >> 2  cog := ofs + constant(cmdHEAP + (regADDR + $C0) >> 9) ' $C0 is based on PASM adjustment       (##)  return hub >< 32 | cog << 9 | cmdLOADPUB encodeLoadSL(start, length)'' Encodes a hub address and a length value into a load command.'''' parameters''    start: address of code fragment       ''   length: length of code fragment in bytes (4n, n > 0)'''' result''  command: load command  return encodeLoadSE(start, start + length - 4)  DAT             org     0                       ' overlay loaderthread          jmpret  $, #init                '  -4   once{done}          wrlong  zero, link              '  +0 = transfer done{idle}          rdlong  addr, link wz           '  +0 = wait for command        if_nz   jmpret  par, addr wc,nr         '  +8   set carry for addr <> 0                 (%%)                jmp     #$-2                    '  -4tail            djnz    addr, #sub7             ' loop tail backupload            rcr     addr, #9                '  -4   cog address (hub:cog:cmd = 14:9:9)      (%%)                movd    phsa, addr              '  +0 = move cog address into base insn         (##)                rev     addr, #{32-}7           '  +4   extract overlay hub address, %-11       (%%)                mov     sub7, phsa              '  +8   update insn                             (##)                mov     heap, tail              '  -4   restore loop tail                sub7            rdlong  0-0, addr               '  +0 = copy long from hub to cog                mov     sub1, phsa              '  +8   update insn                sub     addr, #7                '  -4   decrement hub address by 1 long (prev by 1, now by 7)sub1            rdlong  0-0, addr               '  +0 = copy long from hub to cog                mov     sub7, phsa              '  +8   update insn                               heap           {djnz    addr, #sub7}            '  -4   decrement hub address by 1 long (prev by 7, now by 1)init            movi    ctra, #%0_11111_000     ' LOGIC always                neg     frqa, #|< (9 - 4)       ' subtract 1 from dst every 16 cycles                mov     phsa, sub7              ' base insn                add     phsa, #|< (9 - 4) * 6   ' adjust for live sample offset (frqx*(4+2))    (##)                mov     link, par               ' default command location                jmp     %%0                     ' ret                fit                CON  zero = $1F0   ' par  addr = $1F3   ' inb  link = $1F5   ' outbDAT