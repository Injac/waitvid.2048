'''' VGA display 51xG (dual cog) - video driver and pixel generator''''        Author: Marko Lukat'' Last modified: 2012/09/18''       Version: 0.9'''' long[par][0]:  screen:      [!Z]:addr =  16:16 -> zero (accepted)'' long[par][1]:    font: size:[!Z]:addr = 8:8:16 -> zero (accepted)'' long[par][2]: palette:      [!Z]:addr =  16:16 -> zero (accepted)'' long[par][3]: frame indicator/sync lock'''' acknowledgements'' - loader code based on work done by Phil Pilgrim (PhiPi) and Ray Rodrick (Cluso99)'''' 20120915: horizontal character scrolling operational'' 20120916: horizontal pixel scrolling operational'' 20120917: vertical pixel scrolling operational'' 20120918: added minimal translation table and missing comments''OBJ  system: "core.con.system"    PUB null'' This is not a top level object.PUB init(ID, mailbox) : release | cog                                        word[mailbox][6] := word[mailbox][7] := @release  cog := system.launch( ID, @reader, mailbox) & 7 {cog :=}system.launch(cog, @reader, mailbox|$8000)  repeat  while long[mailbox][3]  release := TRUEDAT             org     0                       ' cog binary headerheader_2048     long    system#ID_2             ' magic number for a cog binary                word    header_size             ' header size                word    system#MAPPING          ' flags                word    0, 0                    ' start register, register count                word    @__table - @header_2048 ' translation table byte offsetheader_size     fit     16                DAT             org     0                       ' video driver and pixel generatorreader          jmpret  $, #setup               ' once                mov     dira, mask              ' drive outputs' horizontal timing 400(800) 40(40) 128(128) 88(88)'   vertical timing 300(600)  1(1)    4(4)   23(23)                vsync           mov     task, #pointer          ' reset task chain (vsync)        '               mov     ecnt, #1                call    #blank                  ' front porch'               djnz    ecnt, #$-1                xor     sync, #%01              ' active                mov     ecnt, #4                call    #blank                  ' vertical sync                djnz    ecnt, #$-1                xor     sync, #%01              ' inactive                mov     ecnt, #23 -2                call    #blank                  ' back porch                djnz    ecnt, #$-1        if_nc   call    #blank                  ' |        if_nc   call    #blank                  ' remaining 2 back porch lines' Vertical sync chain done, do visible area.                mov     zwei, scry              ' relative screen base address                shr     zwei, #3                ' remove scanline index                shl     zwei, #6                ' 64 columns/line                                mov     lcnt, #150              ' (2x prep + 2x emit) * 150 = 600                mov     slot, scry              ' scan line index 0..7  (@@)                and     slot, #%0111            ' primary = ++secondary & 7:line           mov     vscl, many              ' |                waitvid zero, #0                ' 260 hub windows for pixel/colour data                                mov     eins, slot              ' |                shl     eins, #9                ' 0K5 per font section                add     eins, font              ' font base + slot offset                call    #load_init                mov     gen_adjust, lhs_adjust                mov     gen_length, lhs_length wz                        if_nz   call    #load_res{ources}       ' pixels & colours                mov     gen_adjust, rhs_adjust                mov     gen_length, rhs_length wz                if_nz   call    #load_res{ources}       ' pixels & colours                call    #prepare                ' upset prefix/suffix palettes                add     slot, #2                ' next slot                test    slot, #%1000 wz         ' check slot state        if_nz   and     slot, #%0111            ' 6 ->(8)-> 0, 7 ->(9)-> 1        if_nz   add     zwei, #res_x >> 3       ' getting past 7 is a line transition        if_nz   and     zwei, mask_screen       ' wrap                ' We collected one scanline worth of data, now send it out.                sub     hs_b, adj_p             ' tail for first scanline                neg     vscl, adj_p             ' |                add     vscl, #32               ' |                waitvid zero, #0                ' 4 hub windows max             (%%)                sub     hs_f, adj_s             ' temporary adjustment                mov     outa, sync              ' take over sync lines                andn    vcfg, #%11              ' disconnect from video h/w     (##)                                jmpret  hsync_ret, emit         ' emit scanline (chained call)                sub     hs_f, adj_s             ' temporary adjustment                mov     outa, sync              ' take over sync lines                andn    vcfg, #%11              ' disconnect from video h/w     (##)                                jmpret  hsync_ret, emit         ' emit scanline (chained call)                djnz    lcnt, #:line                                                ' secondary finishes early so        if_c    call    #blank                  ' let him do some blank lines        if_c    call    #blank                  ' before restarting                jmp     #vsync                blank           mov     vscl, line              ' 200/800                waitvid sync, #%%0000                ' This is where we can update screen buffer, font definition and palette.' With the setup used we have about 100 hub windows available per line.                jmpret  task, taskhsync           mov     vscl, hs_f              ' 256/40                waitvid sync, #%%0              ' latch front porch                mov     hs_f, #40               ' auto-reset                                                                                                or      vcfg, #%11              ' drive sync lines              (##)                mov     outa, #0                ' stop interfering                                xor     sync, #%10              ' active                mov     vscl, #128              ' 256/128                waitvid sync, #%%0              ' latch sync                xor     sync, #%10              ' inactive                mov     vscl, hs_b              ' 256/88                waitvid sync, #%%0              ' latch back porch                mov     hs_b, #88               ' auto-resethsync_retblank_ret       ret' Line emitter subroutines (0/123/4/567).emit_0          movs    :vid, #pix+0            ' |                movd    :vid, #pal+0            ' restore initial settings                mov     ecnt, #50 -0            ' character count                mov     vscl, full              ' character timing:vid            waitvid 0-0, 0-0                ' send scanline core                add     :vid, d1s1              ' advance dst/src                djnz    ecnt, #:vid                jmp     #hsync                  ' chain callemit_123        movs    :vid, #pix+1            ' |                movd    :vid, #pal+1            ' restore initial settings                mov     ecnt, #50 -1            ' character count                mov     temp, pix+0             ' |                shr     temp, #8                ' |                mov     vscl, half              ' |                waitvid pal_p, #%%0123          ' |                waitvid pal+0, temp             ' prefix                                mov     vscl, full              ' character timing:vid            waitvid 0-0, 0-0                ' send scanline core                add     :vid, d1s1              ' advance dst/src                djnz    ecnt, #:vid                mov     vscl, half              ' |                waitvid pal_s, #%%3210          ' suffix                jmp     #hsync                  ' chain call                emit_4          movs    :vid, #pix+1            ' |                movd    :vid, #pal+1            ' restore initial settings                mov     ecnt, #50 -1            ' character count                mov     temp, pix+0             ' |                shr     temp, #8                ' |                mov     vscl, half              ' |                waitvid pal+0, temp             ' prefix                                mov     vscl, full              ' character timing:vid            waitvid 0-0, 0-0                ' send scanline core                add     :vid, d1s1              ' advance dst/src                djnz    ecnt, #:vid                mov     vscl, half              ' |                waitvid pal+50, pix+50          ' suffix                jmp     #hsync                  ' chain callemit_567        movs    :vid, #pix+1            ' |                movd    :vid, #pal+1            ' restore initial settings                mov     ecnt, #50 -1            ' character count                mov     vscl, half              ' |                waitvid pal_p, #%%0123          ' prefix                                mov     vscl, full              ' character timing:vid            waitvid 0-0, 0-0                ' send scanline core                add     :vid, d1s1              ' advance dst/src                djnz    ecnt, #:vid                mov     vscl, half              ' |                waitvid pal+50, pix+50          ' |                waitvid pal_s, #%%3210          ' suffix                jmp     #hsync                  ' chain call' Line emitter support code (palette creator).prepare         test    scrx, #%000000_011 wz        if_z    jmp     prepare_ret             ' nothing to dosave_c          muxc    restore_c, #1'                 0    1    2    3    4    5    6    7' pal_p          n/a -BCD --CD ---D  n/a -FGH --GH ---H   %%0123' pal_s          n/a ---A --BA -CBA  n/a ---E --FE -GFE   %%3210                mov     pal_p, #0               ' start with black                mov     pal_s, #0               ' for all entries                neg     ecnt, scrx              ' |                and     ecnt, #%11              ' prefix colour count                mov     temp, ecnt              ' remember for normalization                mov     pix_t, pix+0            ' HGFEDCBA                test    scrx, #%000000_100 wz        if_z    rev     pix_t, #{32-}24         ' ----abcd        if_nz   rev     pix_t, #{32-}16         ' abcdefgh        :prefix         mov     pal_t, pal+0            ' 1st column                shr     pix_t, #1 wc            ' index >> offset        if_c    shr     pal_t, #16              ' |                shr     pix_t, #1 wc            ' rev %00 %10 %01 %11        if_c    shr     pal_t, #8               ' shr   0   8  16  24                and     pal_t, #$FF             ' extract palette entry                or      pal_p, pal_t            ' and squirrel it away                ror     pal_p, #8               ' for later                                djnz    ecnt, #:prefix          ' waitvid pal_p, #%%0123                shl     temp, #3                ' |                rol     pal_p, temp             ' normalize palette                mov     ecnt, scrx              ' |                and     ecnt, #%11              ' suffix colour count                mov     temp, ecnt              ' remember for normalization                mov     pix_t, pix+50           ' HGFEDCBA                test    scrx, #%000000_100 wz        if_nz   shr     pix_t, #8               ' ----HGFE:suffix         mov     pal_t, pal+50           ' 51st column                shr     pix_t, #1 wc            ' index >> offset        if_c    shr     pal_t, #8               ' |                shr     pix_t, #1 wc            ' nop %00 %01 %10 %11        if_c    shr     pal_t, #16              ' shr   0   8  16  24                and     pal_t, #$FF             ' extract palette entry                or      pal_s, pal_t            ' and squirrel it away                ror     pal_s, #8               ' for later                                            djnz    ecnt, #:suffix          ' waitvid pal_s, #%%3210                shl     temp, #3                ' |                rol     pal_s, temp             ' normalize paletterestore_c       test    $, #1 wcprepare_ret     ret' Pixel and palette loader.load_init       movd    lp_one, #pix+0          ' |                movd    lp_two, #pix+1          ' restore initial settings                sub     lp_one, load_offset     ' |                sub     lp_two, load_offset     ' adjust for even/odd                movd    lc_one, #pal+0          ' |                movd    lc_two, #pal+1          ' restore initial settings                sub     lc_one, load_offset     ' |                sub     lc_two, load_offset     ' adjust for even/oddload_init_ret   retload_res        mov     frqb, scrn              ' current screen base                sub     frqb, zwei              ' and offset                shr     frqb, #1{/2}            ' frqb is added twice                     addabs  frqb, gen_adjust        ' offset within row                abs     phsb, gen_length        ' byte count -1                lp_loop         rdbyte  temp, phsb              ' get character                shl     temp, #1                ' word index                add     temp, eins              ' add current font baselp_one          rdword  0-0, temp               ' read one scan line of character                add     $-1, dst2               ' advance destination                sub     phsb, #1 wz                rdbyte  temp, phsb              ' get character                shl     temp, #1                ' word index                add     temp, eins              ' add current font baselp_two          rdword  0-0, temp               ' read one scan line of character                add     $-1, dst2               ' advance destination        if_nz   djnz    phsb, #lp_loop                abs     phsb, gen_length        ' byte count -1lc_loop         rdbyte  temp, phsb              ' get character                shl     temp, #2                ' long index                add     temp, plte              ' add current palette baselc_one          rdlong  0-0, temp               ' read palette entry                add     $-1, dst2               ' advance destination                sub     phsb, #1 wz                rdbyte  temp, phsb              ' get character                shl     temp, #2                ' long index                add     temp, plte              ' add current palette baselc_two          rdlong  0-0, temp               ' read palette entry                add     $-1, dst2               ' advance destination        if_nz   djnz    phsb, #lc_loop                load_res_ret    ret' Stuff to do during vertical blank.pointer         mov     vref, cnt               ' waitvid reference                wrlong  vref, fcnt_             ' announce vertical blank                mov     href, cnt               ' hub window reference                sub     href, vref                shr     href, #1                ' 12/13 -> 6        if_c    cmp     href, #6 wz             ' secondary (primary missed hub window)                mov     cnt, #5{18} + 6         ' |  if_z_and_c    add     cnt, #16                ' |                add     cnt, cnt                ' |                waitcnt cnt, #0                 ' bring primary/secondary back in line                rdlong  temp, scrn_ wz          ' |        if_nz   mov     scrn, temp              ' |        if_nz   wrlong  zero, scrn_             ' update and acknowledge screen buffer setup                        rdlong  temp, font_ wz          ' |        if_nz   mov     font, temp              ' |        if_nz   wrlong  zero, font_             ' update and acknowledge font definition setup                rdlong  temp, plte_ wz          ' |        if_nz   mov     plte, temp              ' |        if_nz   wrlong  zero, plte_             ' update and acknowledge palette setup{split}         jmpret  task, task{split}         jmpret  task, task                                                                               ' scroll coordinates are sampled two scanlines after vertical blank indication  00: 33 06 00 20'                                                                               01: 33 05 00 20                mov     temp, plte              '                               02: 33 04 00 20                sub     temp, #4                '                               03: 33 03 00 20                rdword  scrx, temp              ' scroll X, palette.word[-2]    04: 33 02 00 20                and     scrx, #511              '                               05: 33 01 00 20                add     temp, #2                '                               06: 33 00 00 20                rdword  scry, temp              ' scroll Y, palette.word[-1]    07: 31 00 01 1F        if_nc   add     scry, #1                ' secondary goes first  (@@)    08: 2F 00 03 1E                and     scry, #511              '                               09: 2D 00 05 1D                                                '                               0A: 2B 00 07 1C                test    scrx, #%1000 wz         ' even: 0                       0B: 29 00 09 1B                muxnz   load_offset, dst1       '  odd: dst1                    0C: 27 00 0B 1A                                                '                               0D: 25 00 0D 19                mov     lhs_length, scrx        '   0..511                      0E: 23 00 0F 18                shr     lhs_length, #4          '   0..31                       0F: 21 00 11 17                mov     lhs_adjust, lhs_length  '                               10: 1F 00 13 16                                                '                               11: 1D 00 15 15                mins    lhs_length, #6          '  =6..31                       12: 1B 00 17 14                mov     rhs_adjust, lhs_length  '                               13: 19 00 19 13                                                '                               14: 17 00 1B 12                shl     lhs_length, #1          ' =12..62[2]                    15: 15 00 1D 11                sub     lhs_length, #63         ' -51..-1[2]                    16: 13 00 1F 10                                                '                               17: 11 00 21 0F                sub     lhs_adjust, #6          '  -6..25                       18: 0F 00 23 0E                maxs    lhs_adjust, #0          '  -6..0=                       19: 0D 00 25 0D                                                '                               1A: 0B 00 27 0C                mov     rhs_length, lhs_length  '                               1B: 09 00 29 0B                add     rhs_length, #51 wz      '   0..50[2]                    1C: 07 00 2B 0A                                                '                               1D: 05 00 2D 09        if_nz   sub     rhs_length, #1          '                               1E: 03 00 2F 08                sub     rhs_adjust, #32 + 6     '      scrx[8..4]: LL LA RL RA  1F: 01 00 31 07                                                                                                movs    :fn, scrx                andn    :fn, #%111111000                add     :fn, #emitters                nop:fn             mov     emit, 0-0                mov     adj_p, scrx                and     adj_p, #%11             ' 0/1/2/3                shl     adj_p, #1               ' 0/2/4/6                neg     adj_s, scrx                and     adj_s, #%11             ' 0/3/2/1                shl     adj_s, #1               ' 0/6/4/2                {split}         jmpret  task, task nr           ' End Of Chain (no more tasks for this frame)' initialised data and/or presetsemitters        long    emit_0                long    emit_123                long    emit_123                long    emit_123                long    emit_4                long    emit_567                long    emit_567                long    emit_567sync            long    hv_idle                 ' preset to idlehs_f            long    40hs_b            long    88half            long      2 << 12 | 8           '   2/8full            long      2 << 12 | 16          '   2/16line            long    200 << 12 | 800         ' 200/800many            long      0 << 12 | 2080        ' 256/2080 (260 hub windows)    (%%)load_offset     long    0                       ' 0/dst1mask_screen     long    res_x * res_y / 64 -1   ' char screen size -1 (wrap support)mask            long    vpin << (vgrp * 8)      ' pin I/O setupd1s1            long    1 << 9 | 1              ' dst/src +/-= 1dst1            long    1 << 9                  ' dst     +/-= 1dst2            long    2 << 9                  ' dst     +/-= 2scrn_           long    $00000000 -12           ' |font_           long    $00000004 -12           ' |plte_           long    $00000008 -12           ' |fcnt_           long    $0000000C -12           ' mailbox addresses (local copy)scrn            long    0                       ' screen buffer   (2n)font            long    0                       ' font definition (2n)plte            long    0                       ' palette address (4n)' Stuff below is re-purposed for temporary storage.setup           add     addr, par wc            ' carry set -> secondary                and     addr, hram              ' confine to hub RAM                add     scrn_, addr             ' @long[par][0]                add     font_, addr             ' @long[par][1]                add     plte_, addr             ' @long[par][2]                add     fcnt_, addr             ' @long[par][3]                muxc    addr, #%10              ' add secondary offset                rdword  lock, addr              ' release lock location                wrword  zero, addr              ' up and running                rdlong  temp, lock wz           ' |        if_z    jmp     #$-1                    ' synchronized start'   primary: cnt + 0              ' secondary: cnt + 2                rdlong  vref, #0                ' clkfreq                shr     vref, #10               ' ~1ms        if_nc   add     vref, #2                ' adjust primary                add     vref, cnt' Upset video h/w ... I don't trust the freezer approach yet (to sync multiple cogs)' so it's done with a slightly modified stretch/restore sequence.                movi    ctrb, #%0_11111_000     ' LOGIC always (loader support)                movi    ctra, #%0_00001_110     ' PLL, VCO / 2                movi    frqa, #%0001_00000      ' 5MHz * 16 / 2 = 40MHz                mov     vscl, #16               ' 256/16                                movd    vcfg, #vgrp             ' pin group                movs    vcfg, #vpin             ' pins                movi    vcfg, #%0_01_1_00_000   ' VGA, 4 colour mode                waitcnt vref, #(16 * 8) * 2     ' PLL settled                waitvid zero, #0                ' dummy (first one is unpredictable)                waitvid zero, #0                ' point of reference                sub     vref, cnt               ' difference to target                shr     vref, #1                ' ... in frame cycles                add     vscl, vref              ' |                waitvid zero, #0                ' stretch frame                mov     vscl, line              ' |                waitvid zero, #0                ' force slow frame' Setup complete, do the heavy lifting upstairs ...                jmp     %%0                     ' returnhram            long    $00007FFF               ' hub RAM mask  addr            long    $FFFF8000 +12                fit                org     setup                ' uninitialised data and/or temporariesecnt            res     1                       ' element/character countlcnt            res     1                       ' line countslot            res     1                       ' character line part [0..7]href            res     1                       ' hub window referencevref            res     1                       ' waitvid referencelock            res     1                       ' release lock locationtask            res     1                       ' task index (vertical)pix_t{emp}      res     1pix             res     52                      ' pattern bufferpal_t{emp}      res     1pal             res     52                      ' palette bufferpal_p{refix}    res     1                       ' prefix palettepal_s{uffix}    res     1                       ' suffix paletteadj_p{refix}    res     1                       ' timing adjustments foradj_s{uffix}    res     1                       ' pixel scrollingemit            res     1                       ' current line emitter functionscrx            res     1                       ' pixel scroll locationscry            res     1                       ' updated once per framegen_adjust      res     1gen_length      res     1lhs_adjust      res     1lhs_length      res     1rhs_adjust      res     1rhs_length      res     1temp            res     1eins            res     1zwei            res     1tail            fit                DAT                                             ' translation table__table         word    (@__names - @__table)/2                word    res_x                word    res_y                __names         byte    "res_x", 0                byte    "res_y", 0CON  zero    = $1F0                                ' par (dst only)  vpin    = $0FF                                ' pin group mask  vgrp    = 2                                   ' pin group  hv_idle = $01010101 * %00 {%hv}               ' h/v sync inactive  res_x   = 512                                 ' |  res_y   = 512                                 ' |  res_m   = 4                                   ' UI support  DAT